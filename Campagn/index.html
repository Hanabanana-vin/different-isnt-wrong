<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Different is not wrong ‚Äì Stress Rhythm Check</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Montserrat+Alternates:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">

</head>

<body>
  <div class="shell">

    <!-- INTRO -->
    <div class="card" id="screen-intro">
      <div class="tagline">Different is not wrong</div>
      <h1 class="intro_h1">Take care of<br>your mental health</h1>
      <p>
        Check your stress levels quickly and easily,<br>and restore your mental wellbeing.
      </p>
      <div class="btn-row">
        <button class="primary" id="btn-start">Start Stress Check</button>
      </div>
    </div>

    <!-- Q1 -->
    <div class="card" id="q1" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q1">‚Üê Back</button>
        <div class="progress-bar">
          <div class="fill" style="width:25%;"></div>
        </div>
      </div>
      <div class="step-label">Question 1 of 5</div>
      <h2>What is your <span class="orange_txt">age group?</span></h2>
      <p>Please answer honestly, just as you normally think.</p>
      <div class="options-block">
        <div class="opt" data-key="identity">10s</div>
        <div class="opt" data-key="identity">20s</div>
        <div class="opt" data-key="identity">30s</div>
        <div class="opt" data-key="identity">40s</div>
        <div class="opt" data-key="identity">50s</div>
        <div class="opt" data-key="identity">over 60s</div>
      </div>
    </div>


    <!-- Q2 -->
    <div class="card" id="q2" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q2">‚Üê Back</button>
        <div class="progress-bar">
          <div class="fill" style="width:50%;"></div>
        </div>
      </div>
      <div class="step-label">Question 2 of 5</div>
      <h2>Should a government be allowed to <span class="orange_txt">restrict civil liberties</span> during a national
        emergency?</h2>
      <img src="q2.jpg" alt="Question 2 Image" class="q-image">
      <p>Please answer honestly, just as you normally think.</p>
      <div class="options-block">
        <div class="opt" data-key="politics">Yes</div>
        <div class="opt" data-key="politics">Sometimes</div>
        <div class="opt" data-key="politics">Rarely</div>
        <div class="opt" data-key="politics">Never</div>
      </div>
    </div>


    <!-- Q3 -->
    <div class="card" id="q3" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q3">‚Üê Back</button>
        <div class="progress-bar">
          <div class="fill" style="width:75%;"></div>
        </div>
      </div>
      <div class="step-label">Question 3 of 5</div>
      <h2>Do you support European bans on <span class="orange_txt">full-face religious coverings</span> <span
          class="small_txt">(burqa/niqab)</span> in
        public spaces?</h2>
      <img src="q3.jpg" alt="Question 3 Image" class="q-image">
      <p>Please answer honestly, just as you normally think.</p>
      <div class="options-block">
        <div class="opt" data-key="gender">Support</div>
        <div class="opt" data-key="gender">Oppose</div>
        <div class="opt" data-key="gender">Depends</div>
        <div class="opt" data-key="gender">Not sure</div>
      </div>
    </div>

    <!-- Q4 -->
    <div class="card" id="q4" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q4">‚Üê Back</button>
        <div class="progress-bar">
          <div class="fill" style="width:80%;"></div>
        </div>
      </div>
      <div class="step-label">Question 4 of 5</div>
      <h2>How do you view Spain‚Äôs <span class="orange_txt">‚ÄòOkupa‚Äô</span> movement ?</h2>
      <p>Okupa: Spain's squatters who occupy empty buildings</p>
      <img src="q4_rr.png" alt="Question 4 Image" class="q-image">
      <p>Please answer honestly, just as you normally think.</p>
      <div class="options-block">
        <div class="opt" data-key="identity">Justified</div>
        <div class="opt" data-key="identity">Unjustified</div>
        <div class="opt" data-key="identity">Context matters</div>
        <div class="opt" data-key="identity">Not sure</div>
      </div>
    </div>

    <!-- Q5 -->
    <div class="card" id="q5" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q5">‚Üê Back</button>
        <div class="progress-bar">
          <div class="fill" style="width: 100%;"></div>
        </div>
      </div>
      <div class="step-label">Question 5 of 5</div>
      <h2>How do you view the growing conflict between younger and older generations over <span class="orange_txt">the
          pension system?</span></h2>
      <img src="q5.jpg" alt="Question 5 Image" class="q-image">
      <p>There is no right or wrong answer.</p>
      <div class="options-block">
        <div class="opt" data-key="stress">Support</div>
        <div class="opt" data-key="stress">Oppose</div>
        <div class="opt" data-key="stress">Depends</div>
        <div class="opt" data-key="stress">Not sure</div>
      </div>
    </div>



    <!-- PRE-MEASURE INSTRUCTION -->
    <div class="card" id="screen-pre-measure" style="display:none;">

      <!-- Top Interaction pointing to camera -->
      <!-- Top Interaction pointing to camera (Moved to global) -->

      <div class="step-label">Preparation</div>
      <h2 class="center" style="margin-bottom: 10px;">Ready to measure?</h2>
      <p class="center">For an accurate stress index, we will measure your heart rate.</p>

      <!-- Line Illustration -->
      <div class="illustration-wrap">
        <img src="Frame 1.png" alt="iPad Camera Instruction" class="instruction-img">
      </div>

      <p class="center" style="margin-top:20px;">
        Please cover the <strong>front camera</strong> completely with your fingertip.
      </p>

      <div class="btn-row">
        <button class="primary" id="btn-start-measure">Start Measurement</button>
      </div>
    </div>

    <!-- STEP 2: MEASURE -->
    <div class="card" id="screen-measure" style="display:none;">
      <div class="step-label">Step 2 ¬∑ Heart rhythm capture</div>
      <div class="center">
        <h2>Please cover the camera<br> with your fingertip.</h2>
        <p>Breathe in and out comfortably.</p>

        <div class="camera-wrap" id="camera-wrap">
          <video id="cam" autoplay playsinline></video>

        </div>

        <p class="tiny">Gently cover the camera with your fingertip and stay still for a moment.</p>


        <div class="loader"></div>
        <div class="scan-percent" id="scan-percent">Requesting camera permission‚Ä¶</div>

        <!-- Ïã§ÏãúÍ∞Ñ Ïã¨Î∞ï Í∑∏ÎûòÌîÑ -->
        <!-- Ïã§ÏãúÍ∞Ñ Ïã¨Î∞ï Í∑∏ÎûòÌîÑ -->
        <canvas id="graph" width="320" height="80"></canvas>
        <p class="tiny" id="signal-status"></p>
        <p class="addtnl_tiny">
          This heartbeat is estimated from tiny light changes on your fingertip.
          It is not a medical measurement, but a way to visualize your rhythm.
        </p>
      </div>
    </div>

    <!-- STEP 3: RESULT -->
    <!-- STEP 3: RESULT CAROUSEL -->
    <div id="screen-result" style="display:none;">
      <div class="carousel-container" id="result-carousel">

        <!-- PAGE 1: Visitor‚Äôs Heartbeat (Formerly Slide 3) -->
        <div class="result-slide active" id="slide-1">
          <div class="slide-content center-text">
            <p class="fade-in-text">Here is the rhythm your heart made.</p>

            <!-- Heart Rate Graphic -->
            <div class="ecg-wrap fade-in-text delay-1">
              <canvas id="result-ecg-canvas" width="300" height="100"></canvas>
            </div>

            <div class="result-bpm fade-in-text delay-1" id="result-bpm">‚Äì bpm</div>
            <div class="result-label fade-in-text delay-2" id="result-label">unique rhythm pattern</div>
          </div>
          <div class="tap-hint">Tap to turn the page ‚Üí</div>
        </div>

        <!-- PAGE 2: The World View (Formerly Slide 1) -->
        <div class="result-slide" id="slide-2">
          <div class="slide-content center-text">
            <h2 class="fade-in-text">There are more than<br><span class="bold">8.2 billion people</span><br>living
              completely different lives.
            </h2>
            <img src="world_map.jpg" class="fade-in-image delay-2" alt="World Map">
            <p class="fade-in-text delay-1">Some start before sunrise.<br>Some move slowly.<br>Some feel safe.<br>Some
              feel watched.</p>
          </div>
          <div class="tap-hint">Tap to turn the page ‚Üí</div>
        </div>

        <!-- PAGE 3: Zoom Into the Visitor (Formerly Slide 2) -->
        <div class="result-slide" id="slide-3">
          <div class="slide-content center-text">
            <h2 class="fade-in-text">Each Rhythm, Its Own Story</h2>
            <p>Just as everyone lives<br>in different environments<br>and rhythms,</p>

            <div class="cluster-map-wrap" style="margin-top: 24px;">
              <img src="world_map.jpg" class="map-bg" alt="World Map">
              <canvas id="cluster-canvas" width="300" height="200"></canvas>
            </div>
            <div class="distribution-desc">
              Each dot is one visitor‚Äôs rhythm today.<br>One glowing point is yours.
            </div>
          </div>
          <div class="tap-hint">Tap to turn the page ‚Üí</div>
        </div>

        <!-- PAGE 4: Position Among Others (Gauge) -->
        <div class="result-slide" id="slide-4">
          <div class="slide-content">
            <h2 class="slide-title fade-in-text">This is where your rhythm sits among the others who stood here today.
            </h2>

            <div class="gauge-card fade-in-text delay-1">
              <div class="gauge-wrap">
                <div class="gauge-bar">
                  <div class="gauge-fill" id="gauge-fill"></div>
                  <div class="gauge-marker" id="gauge-marker"></div>
                </div>
                <div class="gauge-labels">
                  <span>Slower</span>
                  <span id="gauge-text">Average</span>
                  <span>Faster</span>
                </div>
              </div>
            </div>

          </div>
          <div class="tap-hint">Tap to turn the page ‚Üí</div>
        </div>

        <!-- PAGE 5: Crowd Visualization -->
        <!-- PAGE 5: Chunk A (Neighborhood) -->
        <div class="result-slide" id="slide-5">
          <div class="slide-content center-text">
            <div class="distribution-card" style="margin-top: 0;">
              <div class="distribution-title">People who moved like you today</div>
              <div class="neighborhood-wrap">
                <div class="nb-card">
                  <div class="nb-count" id="nb-count-2">--</div>
                  <div class="nb-label">Almost the same beat</div>
                </div>
                <div class="nb-card">
                  <div class="nb-count" id="nb-count-5">--</div>
                  <div class="nb-label">Similar rhythm</div>
                </div>
                <div class="nb-card">
                  <div class="nb-count" id="nb-count-unique">--</div>
                  <div class="nb-label">Exactly your beat</div>
                </div>
              </div>
              <div class="distribution-desc">
                Quite a few hearts today moved almost like yours.
              </div>
            </div>
          </div>
          <div class="tap-hint">Tap to turn the page ‚Üí</div>
        </div>

        <!-- PAGE 6: Chunk D (Heart Twin) -->
        <div class="result-slide" id="slide-6">
          <div class="slide-content center-text">
            <div class="heart-twin-card-container" id="twin-card-container">
              <!-- Front of card (before reveal) -->
              <div class="heart-twin-card twin-front">
                <div class="distribution-title">Your Heart Twin</div>
                <div class="twin-icon-mystery">?</div>
                <div class="distribution-desc">
                  Tap to reveal your heart twin...
                </div>
                <div class="shimmer-effect"></div>
              </div>
              <!-- Back of card (after reveal) - Profile Card -->
              <div class="heart-twin-card twin-back">
                <div class="twin-profile-badge">MATCHED</div>
                <div class="twin-country-flag" id="twin-flag">üåç</div>
                <div class="twin-profile-name" id="twin-name">Heart Twin</div>
                <div class="twin-profile-location" id="twin-location">Somewhere on Earth</div>
                <div class="twin-profile-divider"></div>
                <div class="twin-profile-bpm">
                  <span class="bpm-number" id="twin-bpm">--</span>
                  <span class="bpm-label">BPM</span>
                </div>
                <div class="twin-profile-note">
                  Your hearts beat in sync ‚ù§Ô∏è
                </div>
              </div>
            </div>
          </div>
          <div class="tap-hint" id="twin-hint">Tap the card to reveal ‚Üí</div>
        </div>

        <!-- PAGE 7: Ending - Dark Cinematic -->
        <div class="result-slide ending-dark" id="slide-7">
          <div class="ending-overlay"></div>
          <div class="slide-content center-text ending-content" style="position: relative; z-index: 2;">
            <!-- Text Messages Container - Centered -->
            <div class="ending-message-cinematic">
              <p class="ending-line-cinematic" data-index="0">Different opinions.</p>
              <p class="ending-line-cinematic" data-index="1">Different fears.</p>
              <p class="ending-line-cinematic" data-index="2">Different sides.</p>
              <p class="ending-line-cinematic bridge-text" data-index="3">Yet every heart here moved inside the same
                human range.</p>
            </div>

            <!-- Heart Drawing + Final Statement Container - Centered -->
            <div class="ending-visual-cinematic">
              <!-- Heart Hug Line Drawing -->
              <div class="heart-drawing-wrap ending-line-cinematic" data-index="4">
                <svg class="heart-hug-svg" viewBox="0 0 5726.48 1798" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path class="draw-line"
                    d="M10.55,1571.4c73.55-42.37,157.86-70.01,238.92-93.35,211.84-61,434.93-80.15,654.51-64.87,152.79,10.64,304.2,38.21,451.56,79.79,167.48,47.25,326.97,117.58,492.13,171.91,225.94,74.33,465.63,137.33,705.41,132.47,143.48-2.91,286.17-35.13,408.19-112.88,107.39-68.43,194.28-167.13,280.47-259.53,137.52-147.44,268.49-302.65,380.24-470.73,57.13-85.92,109.47-175.72,149.67-270.91,33.76-79.94,59.99-165.37,62.57-252.7,2.29-77.64-16.99-155.06-64.07-217.75-34.21-45.55-80.34-82.91-126.46-115.74-51.41-36.59-108.34-66.61-169.45-83.21-104.16-28.29-212.61-11.27-304.6,44.59-102.51,62.24-178.87,161.45-234.84,265.88-31.69,59.14-57.32,121.36-78.36,185.03-2.86,8.65,10.77,12.35,13.61,3.75,71.07-215.03,224.09-482.49,478.73-498.49,129.26-8.12,248.82,56.64,343.92,138.92,66.27,57.33,112.87,125,124.46,213.42,10.9,83.15-6.82,167.94-33.72,246.42-32.15,93.81-78.94,182.3-130.73,266.62-106.72,173.74-236.87,332.84-373.69,483.58-51.49,56.73-104.29,112.28-158.12,166.8-39.88,40.39-80.29,80.02-126.03,113.86-108.99,80.64-237.89,123.63-372.41,135.32-219.01,19.02-441.31-29.55-650.27-90.71-74.31-21.75-147.9-45.95-220.86-71.86-82.38-29.26-163.23-62.61-245.74-91.45-150.07-52.45-305.09-90.9-462.68-112.21-231.14-31.27-468.05-25.42-696.03,25.34-112.73,25.1-226.22,59.92-329.27,112.94-4.76,2.45-9.54,4.91-14.18,7.59-7.87,4.53-.77,16.74,7.12,12.19h0Z"
                    stroke="white" stroke-width="8" stroke-linecap="round" />
                  <path class="draw-line"
                    d="M5723.05,1559.21c-70.05-40.35-150.02-67.3-227.03-90.3-199.9-59.68-410.68-81.89-618.8-72.93-143.66,6.19-286.61,27.4-426.29,61.38-80.07,19.48-159.11,43.17-236.82,70.57-83.38,29.4-165.18,63.06-248.57,92.47-235.28,83-483.47,155.59-734.62,162.58-147.8,4.11-297.86-18.76-427.95-92.29-105.9-59.86-188.82-149.81-271.82-237.07-133.95-140.81-261.78-288.54-373.94-447.45-59.5-84.3-114.84-172.05-160.37-264.76-40.35-82.17-74.3-169.95-86.4-261.18-10.21-77.01-2.87-157.42,35.72-226.08,23.3-41.45,56.51-74.09,92.44-104.71,53.8-45.85,114.24-85.75,180.87-110.24,104.73-38.5,217.23-31.52,315.08,22.67,105.7,58.54,183.95,157.98,241.06,262.46,32.92,60.22,59.3,123.71,80.82,188.82,2.84,8.59,16.47,4.91,13.61-3.75-70.86-214.4-217.68-472.15-464.96-506.08-119.05-16.34-234.53,29.6-329.45,98.97-77.14,56.37-145.7,122.79-171.22,217.35-46.22,171.22,37.5,357.29,119.64,503.69,102.14,182.06,233.6,347.54,371.57,503.55,56.18,63.53,114.06,125.55,173.25,186.28,40.84,41.9,81.54,84.22,127.04,121.15,103.35,83.89,225.93,135.08,357.58,153.64,206.43,29.1,419.12-9.06,618.61-61.55,155.18-40.83,307.1-93.48,456.59-151.58,155.75-60.54,316.31-107.78,481.14-135.99,245.61-42.04,499.56-42.41,743.86,8.7,118.96,24.89,239.13,60.36,347.66,116.1,4.9,2.51,9.8,5.04,14.58,7.79,7.89,4.54,15-7.65,7.12-12.19h0Z"
                    stroke="white" stroke-width="8" stroke-linecap="round" />
                </svg>
              </div>

              <h2 class="ending-line-cinematic final-statement" data-index="4">Different is not wrong.</h2>

              <button id="btn-restart" class="btn-restart-dark ending-line-cinematic" data-index="5"
                onclick="resetApp()">
                Try Again
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- PPG Î∂ÑÏÑùÏö© Ïà®ÏùÄ Ï∫îÎ≤ÑÏä§ -->
    <canvas id="ppg-canvas" width="64" height="48" style="display:none;"></canvas>

  </div>

  <!-- Global Instruction Graphic (Fixed to Top) -->
  <div class="instruction-graphic" id="instruction-graphic" style="display:none;">
    <div class="finger-cue"></div>
    <div class="arrow-cue">‚Üë</div>
  </div>

  <script>
    // ÌôîÎ©¥ ÏöîÏÜåÎì§
    const intro = document.getElementById('screen-intro');
    const q1 = document.getElementById('q1');
    const q2 = document.getElementById('q2');
    const q3 = document.getElementById('q3');
    const q4 = document.getElementById('q4');
    const q5 = document.getElementById('q5');
    const pmScreen = document.getElementById('screen-pre-measure');
    const mScreen = document.getElementById('screen-measure');
    const rScreen = document.getElementById('screen-result');
    const instructionGraphic = document.getElementById('instruction-graphic');

    const btnStart = document.getElementById('btn-start');
    const btnStartMeasure = document.getElementById('btn-start-measure');
    const btnRestart = document.getElementById('btn-restart');

    const backQ1 = document.getElementById('back-q1');
    const backQ2 = document.getElementById('back-q2');
    const backQ3 = document.getElementById('back-q3');
    const backQ4 = document.getElementById('back-q4');
    const backQ5 = document.getElementById('back-q5');

    const bpmEl = document.getElementById('result-bpm');
    const labelEl = document.getElementById('result-label');

    const nrMarkerLine = document.getElementById("nr-marker-line");
    const nrMarkerDot = document.getElementById("nr-marker-dot");
    const nrMarkerLabel = document.getElementById("nr-marker-label");
    const nrBpmInline = document.getElementById("nr-bpm-inline");


    const scanPercentEl = document.getElementById('scan-percent');
    const signalStatusEl = document.getElementById('signal-status');
    const camWrap = document.getElementById('camera-wrap');
    const video = document.getElementById('cam');

    const ppgCanvas = document.getElementById('ppg-canvas');
    const ppgCtx = ppgCanvas.getContext('2d');

    const graphCanvas = document.getElementById('graph');
    const graphCtx = graphCanvas.getContext('2d');



    function updateNormalMarker(bpm) {
      const normalMin = 50;
      const normalMax = 120;
      const range = normalMax - normalMin;

      const clamped = Math.max(normalMin, Math.min(normalMax, bpm));
      const t = (clamped - normalMin) / range; // 0~1

      // boundary: 10% ~ 90%
      const x = 10 + t * 80;

      nrMarkerLine.setAttribute("x1", x);
      nrMarkerLine.setAttribute("x2", x);
      nrMarkerDot.setAttribute("cx", x);
      nrMarkerLabel.setAttribute("x", x);

      nrBpmInline.textContent = `${bpm} bpm`;
    }

    let camStream = null;
    let scanAnimFrame = null;

    // PPG ÏàòÏßëÏö©
    let ppgData = [];     // {t, v}
    let ppgFrameHandle = null;
    let ppgStartTime = 0;

    let graphData = [];
    const QUALITY_WIN = 40;
    let qualityWindow = [];
    let signalOk = false;
    let ppgMode = false;

    let scanProgress = 0;

    let answers = {
      politics: null,
      gender: null,
      identity: null,
      stress: null,
    };

    function show(screen) {
      // Hide all screens
      [intro, q1, q2, q3, q4, q5, pmScreen, mScreen, rScreen].forEach(s => s.style.display = 'none');
      // Show target
      screen.style.display = 'block';

      // Toggle global instruction graphic
      if (screen === pmScreen) {
        instructionGraphic.style.display = 'block';
      } else {
        instructionGraphic.style.display = 'none';
      }

      // Scroll to top
      window.scrollTo(0, 0);
    }

    btnStart.onclick = () => show(q1);

    // Ï∏°Ï†ï ÏãúÏûë Î≤ÑÌäº
    btnStartMeasure.onclick = () => {
      show(mScreen);
      startCamera();
    };

    // Îí§Î°úÍ∞ÄÍ∏∞
    backQ1.onclick = () => show(intro);
    backQ2.onclick = () => show(q1);
    backQ3.onclick = () => show(q2);
    backQ4.onclick = () => show(q3);
    backQ5.onclick = () => show(q4);

    // ÏßàÎ¨∏ ÏÑ†ÌÉù
    q1.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.politics = opt.textContent.trim();
        q1.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(q2);
      });
    });

    q2.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.gender = opt.textContent.trim();
        q2.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(q3);
      });
    });

    q3.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.gender = opt.textContent.trim();
        q3.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(q4);
      });
    });

    q4.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.identity = opt.textContent.trim();
        q4.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(q5);
      });
    });

    q5.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.stress = opt.textContent.trim();
        q5.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(pmScreen);
      });
    });

    // Ïπ¥Î©îÎùº + PPG
    async function startCamera() {
      scanPercentEl.textContent = "Requesting camera permission‚Ä¶";
      signalStatusEl.textContent = "";

      if (camStream && camStream.active) {
        console.log("Camera already active");
        // If camera is already active, just ensure video is playing and PPG is running
        video.play();
        ppgMode = true;
        scanProgress = 0;
        startPPG(); // Re-start PPG if it was stopped
        startScanAnimation(); // Re-start scan animation
        return;
      }

      try {
        camStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'user',
            width: { ideal: 320 },
            height: { ideal: 240 }
          }
        });
        video.srcObject = camStream;
        video.play();
        ppgMode = true;
        startPPG();
        startScanAnimation();
      } catch (e) {
        console.warn("Camera error:", e);
        ppgMode = false;
        signalStatusEl.textContent = "Camera unavailable. We will simulate your rhythm.";
        startScanAnimation();
      }
    }

    function stopCamera() {
      if (!camStream) return;
      camStream.getTracks().forEach(t => t.stop());
      camStream = null;
      video.srcObject = null;
    }

    // PPG ÏàòÏßë ÏãúÏûë
    function startPPG() {
      ppgData = [];
      graphData = [];
      qualityWindow = [];
      signalOk = false;
      ppgStartTime = performance.now();

      function capture(now) {
        if (!video.videoWidth || !video.videoHeight) {
          ppgFrameHandle = requestAnimationFrame(capture);
          return;
        }
        const w = ppgCanvas.width;
        const h = ppgCanvas.height;
        ppgCtx.drawImage(video, 0, 0, w, h);
        const frame = ppgCtx.getImageData(0, 0, w, h).data;
        let sum = 0;
        let count = 0;
        const startX = Math.floor(w * 0.25);
        const endX = Math.floor(w * 0.75);
        const startY = Math.floor(h * 0.25);
        const endY = Math.floor(h * 0.75);

        for (let y = startY; y < endY; y++) {
          for (let x = startX; x < endX; x++) {
            const idx = (y * w + x) * 4;
            const r = frame[idx]; // R Ï±ÑÎÑê
            sum += r;
            count++;
          }
        }
        const avg = sum / count;
        const t = (now - ppgStartTime) / 1000;
        ppgData.push({ t, v: avg });

        // ÌíàÏßà ÌèâÍ∞ÄÏö© ÏúàÎèÑÏö∞
        qualityWindow.push(avg);
        if (qualityWindow.length > QUALITY_WIN) qualityWindow.shift();
        if (qualityWindow.length >= QUALITY_WIN) {
          let qMin = Infinity, qMax = -Infinity;
          for (const v of qualityWindow) {
            if (v < qMin) qMin = v;
            if (v > qMax) qMax = v;
          }
          const amp = qMax - qMin; // Î≥ÄÌôîÌè≠
          if (amp < 2) {
            // Í±∞Ïùò Î≥ÄÎèô ÏóÜÏùå ‚Üí ÏÜêÍ∞ÄÎùΩ Ïïà Í∞ÄÎ†§Ïßê/ÎÑàÎ¨¥ Ïñ¥ÎëêÏõÄ
            signalOk = false;
            signalStatusEl.textContent = "We can‚Äôt clearly see your fingertip. Please fully cover the camera and stay still.";
          } else {
            signalOk = true;
            signalStatusEl.textContent = "We are detecting subtle changes in your blood flow. Keep still‚Ä¶";
          }
        } else {
          signalStatusEl.textContent = "Trying to lock onto your rhythm‚Ä¶";
        }

        // Í∑∏ÎûòÌîÑÏö© Îç∞Ïù¥ÌÑ∞
        graphData.push(avg);
        if (graphData.length > 400) graphData.shift();
        drawGraph();

        ppgFrameHandle = requestAnimationFrame(capture);
      }

      if (ppgFrameHandle) cancelAnimationFrame(ppgFrameHandle);
      ppgFrameHandle = requestAnimationFrame(capture);
    }

    function stopPPG() {
      if (ppgFrameHandle) cancelAnimationFrame(ppgFrameHandle);
      ppgFrameHandle = null;
    }

    // Ïã§ÏãúÍ∞Ñ ÌååÌòï Í∑∏ÎûòÌîÑ
    function drawGraph() {
      const w = graphCanvas.width;
      const h = graphCanvas.height;
      graphCtx.clearRect(0, 0, w, h);
      if (graphData.length < 2) return;

      let gMin = Infinity, gMax = -Infinity;
      for (const v of graphData) {
        if (v < gMin) gMin = v;
        if (v > gMax) gMax = v;
      }
      const amp = gMax - gMin || 1;

      graphCtx.beginPath();
      for (let i = 0; i < graphData.length; i++) {
        const norm = (graphData[i] - gMin) / amp; // 0~1
        const x = (i / (graphData.length - 1)) * w;
        const y = h - (0.2 + norm * 0.6) * h;     // Í∞ÄÏö¥Îç∞ Îù†Ïóê Í∑∏Î¶¨Í∏∞
        if (i === 0) graphCtx.moveTo(x, y);
        else graphCtx.lineTo(x, y);
      }
      graphCtx.strokeStyle = 'rgba(186,214,235,0.9)';
      graphCtx.lineWidth = 2;
      graphCtx.stroke();
    }

    // Ïä§Ï∫î ÏßÑÌñâ (ÏãúÍ∞Ñ + Ïã†Ìò∏ÌíàÏßà Í∏∞Î∞ò)
    function startScanAnimation() {
      if (scanAnimFrame) cancelAnimationFrame(scanAnimFrame);
      const start = performance.now();
      let last = start;
      scanProgress = 0;

      const TARGET = 12000; // 12Ï¥à Ï†ïÎèÑ Î™©Ìëú
      const MAX = 18000;    // ÏµúÏû• 18Ï¥à

      function tick(now) {
        const elapsed = now - start;
        const dt = now - last;
        last = now;

        if (!ppgMode) {
          // Ïπ¥Î©îÎùº ÏóÜÎäî Í≤ΩÏö∞: Í∑∏ÎÉ• ÏãúÍ∞Ñ Í∏∞Î∞ò
          scanProgress = Math.min(100, (elapsed / TARGET) * 100);
        } else {
          const baseSpeed = (dt / TARGET) * 100;
          const qualityFactor = signalOk ? 1.2 : 0.3; // ÌíàÏßà ÎÇòÏÅòÎ©¥ ÎäêÎ¶¨Í≤å
          scanProgress = Math.min(100, scanProgress + baseSpeed * qualityFactor);

          // ÎÑàÎ¨¥ Ïò§Îûò Í±∏Î¶¨Î©¥ Í∞ïÏ†úÎ°ú ÎßàÎ¨¥Î¶¨
          if (elapsed > MAX && scanProgress < 100) {
            scanProgress = Math.min(100, scanProgress + baseSpeed * 2);
          }
        }

        const pct = Math.round(Math.min(100, scanProgress));
        scanPercentEl.textContent = `Scanning your heart rhythm‚Ä¶ ${pct}%`;

        // Ïπ¥Î©îÎùº ÎßÅ ÏÜçÎèÑÎèÑ Ï†êÏ†ê Îπ®ÎùºÏßÄÍ≤å
        const progress = pct / 100;
        const duration = 1.6 - progress * 0.6; // 1.6s ‚Üí 1.0s
        camWrap.style.animationDuration = duration + "s";

        if (pct < 100) {
          scanAnimFrame = requestAnimationFrame(tick);
        } else {
          stopPPG();
          stopCamera();
          const measured = ppgMode ? computeBPMFromPPG(ppgData) : null;
          show(rScreen);
          // Small delay to ensure layout is done
          setTimeout(() => generateResult(measured), 50);
        }
      }
      scanAnimFrame = requestAnimationFrame(tick);
    }

    // PPG ‚Üí BPM
    function computeBPMFromPPG(data) {
      if (!data || data.length < 30) return null;

      const times = data.map(d => d.t);
      const values = data.map(d => d.v);

      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const centered = values.map(v => v - mean);
      const sq = centered.map(v => v * v);
      const std = Math.sqrt(sq.reduce((a, b) => a + b, 0) / centered.length) || 1;
      const norm = centered.map(v => v / std);

      const win = 5;
      const smooth = norm.map((v, i) => {
        let s = 0, c = 0;
        for (let k = -win; k <= win; k++) {
          const idx = i + k;
          if (idx >= 0 && idx < norm.length) { s += norm[idx]; c++; }
        }
        return s / c;
      });

      const peaks = [];
      const threshold = 0.25;
      for (let i = 1; i < smooth.length - 1; i++) {
        if (smooth[i] > smooth[i - 1] && smooth[i] > smooth[i + 1] && smooth[i] > threshold) {
          peaks.push(i);
        }
      }
      if (peaks.length < 2) return null;

      const intervals = [];
      for (let i = 1; i < peaks.length; i++) {
        const t1 = times[peaks[i - 1]];
        const t2 = times[peaks[i]];
        intervals.push(t2 - t1);
      }
      const avgInt = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      if (!avgInt || avgInt <= 0) return null;

      const bpm = 60 / avgInt;
      if (bpm < 40 || bpm > 180) return null;
      return Math.round(bpm);
    }

    const clusterCanvas = document.getElementById('cluster-canvas');
    const clusterCtx = clusterCanvas.getContext('2d');
    const gaugeFill = document.getElementById('gauge-fill');
    const gaugeMarker = document.getElementById('gauge-marker');
    const gaugeText = document.getElementById('gauge-text');
    const gaugeInsight = document.getElementById('gauge-insight');
    const histWrap = document.getElementById('histogram-wrap');
    const histInsight = document.getElementById('hist-insight');
    const nbCount2 = document.getElementById('nb-count-2');
    const nbCount5 = document.getElementById('nb-count-5');
    const nbCountUnique = document.getElementById('nb-count-unique');
    const twinDesc = document.getElementById('twin-desc');

    // Fake Population Data
    let populationData = [];

    function generateFakePopulation() {
      populationData = [];
      const count = 200;
      const mean = 80;
      const std = 15;

      for (let i = 0; i < count; i++) {
        // Box-Muller transform for normal distribution
        const u = 1 - Math.random();
        const v = Math.random();
        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        const bpm = Math.round(z * std + mean);
        // Variability (fake metric for Y-axis)
        const variability = Math.random() * 100;
        populationData.push({ bpm, variability, id: i + 1 });
      }
    }

    // Carousel Logic
    let currentSlide = 1;
    const totalSlides = 7;

    function showSlide(index) {
      for (let i = 1; i <= totalSlides; i++) {
        const slide = document.getElementById(`slide-${i}`);
        if (i === index) {
          slide.classList.add('active');

          // Trigger Animations based on Slide
          if (index === 3) { // Cluster Map (Moved to Slide 3)
            animateClusterMap();
          } else if (index === 4) { // Gauge
            animateGauge();
          } else if (index === 5) { // Neighborhood
            animateNeighborhood();
          } else if (index === 6) { // Heart Twin
            resetHeartTwinCard();
          } else if (index === 7) { // Ending
            animateEnding();
          }

        } else {
          slide.classList.remove('active');

          // Reset animations if needed (optional, for replayability)
          if (i === 4) resetGauge();
          if (i === 6) resetHeartTwinCard();
        }
      }
      currentSlide = index;
    }

    function nextSlide() {
      if (currentSlide < totalSlides) {
        showSlide(currentSlide + 1);
      }
    }

    // Tap to advance
    document.getElementById('result-carousel').addEventListener('click', (e) => {
      // Don't advance if clicking a button
      if (e.target.tagName === 'BUTTON') return;
      nextSlide();
    });

    // Also allow clicking the hint specifically
    document.querySelectorAll('.tap-hint').forEach(hint => {
      hint.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent double firing
        nextSlide();
      });
    });

    // Animation Helpers
    function animateCount(obj, end, duration) {
      if (!obj) return;
      let startTimestamp = null;
      const start = 0;
      const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        // Ease out quart
        const ease = 1 - Math.pow(1 - progress, 4);
        const current = Math.floor(ease * (end - start) + start);
        obj.textContent = current;
        if (progress < 1) {
          window.requestAnimationFrame(step);
        } else {
          obj.textContent = end;
        }
      };
      window.requestAnimationFrame(step);
    }

    function animateNeighborhood() {
      // Get values from data attributes or global state? 
      // We can read the target value from the element if we stored it, 
      // or just re-calculate. Since we have `updateNeighborhoodStats` which sets text,
      // let's modify `updateNeighborhoodStats` to store value in dataset and set text to 0 initially.

      const el2 = document.getElementById('nb-count-2');
      const el5 = document.getElementById('nb-count-5');
      const elU = document.getElementById('nb-count-unique');

      if (el2.dataset.target) animateCount(el2, parseInt(el2.dataset.target), 1500);
      if (el5.dataset.target) animateCount(el5, parseInt(el5.dataset.target), 1500);
      if (elU.dataset.target) animateCount(elU, parseInt(elU.dataset.target), 1500);
    }

    function animateHistogram() {
      const bars = document.querySelectorAll('.hist-bar');
      bars.forEach((bar, i) => {
        setTimeout(() => {
          bar.style.height = bar.dataset.height;
        }, i * 100); // Staggered effect
      });
    }

    function animateGauge() {
      // Small delay to ensure transition works after display block
      setTimeout(() => {
        if (gaugeFill.dataset.target) gaugeFill.style.width = gaugeFill.dataset.target;
        if (gaugeMarker.dataset.target) gaugeMarker.style.left = gaugeMarker.dataset.target;
      }, 100);
    }

    function resetGauge() {
      gaugeFill.style.width = '0%';
      gaugeMarker.style.left = '0%';
    }

    function resetHistogram() {
      const bars = document.querySelectorAll('.hist-bar');
      bars.forEach(bar => {
        bar.style.height = '0%';
      });
    }

    let clusterAnimFrame = null;
    function animateClusterMap() {
      if (clusterAnimFrame) cancelAnimationFrame(clusterAnimFrame);
      const w = clusterCanvas.width;
      const h = clusterCanvas.height;
      // We need userBpm to draw the user dot correctly. 
      // It's not easily accessible here unless we store it globally.
      // Let's assume `lastMeasuredBpm` is available or we pass it.
      // For now, let's make `drawClusterMap` handle the static draw and we just overlay animation?
      // Better: Re-run the draw with a progress factor.

      let progress = 0;
      const duration = 2000;
      let start = null;

      function step(timestamp) {
        if (!start) start = timestamp;
        const elapsed = timestamp - start;
        progress = Math.min(elapsed / duration, 1);

        drawClusterMap(lastMeasuredBpm, progress); // Modified draw function

        if (progress < 1) {
          clusterAnimFrame = requestAnimationFrame(step);
        }
      }
      clusterAnimFrame = requestAnimationFrame(step);
    }

    // ECG Animation
    const ecgCanvas = document.getElementById('result-ecg-canvas');
    const ecgCtx = ecgCanvas.getContext('2d');
    let ecgFrame = null;

    function startECGAnimation(bpm) {
      if (ecgFrame) cancelAnimationFrame(ecgFrame);

      const width = ecgCanvas.width;
      const height = ecgCanvas.height;
      const centerY = height / 2;

      let x = 0;
      const speed = 2; // pixels per frame
      const intervalFrames = (60 / bpm) * 60; // approx frames per beat (assuming 60fps)
      let framesSinceBeat = 0;

      // Clear canvas
      ecgCtx.fillStyle = '#fff';
      ecgCtx.fillRect(0, 0, width, height);
      ecgCtx.lineWidth = 2;
      ecgCtx.strokeStyle = '#EF4444'; // Red color
      ecgCtx.lineCap = 'round';
      ecgCtx.lineJoin = 'round';

      ecgCtx.beginPath();
      ecgCtx.moveTo(0, centerY);

      let lastY = centerY;

      function loop() {
        framesSinceBeat++;

        // Calculate Y based on beat timing
        let y = centerY;

        // Trigger beat
        if (framesSinceBeat >= intervalFrames) {
          framesSinceBeat = 0;
        }

        // Draw the complex at the start of the beat
        const t = framesSinceBeat; // frames into the beat

        // P wave (small bump)
        if (t > 5 && t < 15) y -= 5 * Math.sin((t - 5) / 10 * Math.PI);
        // QRS complex (sharp down-up-down)
        else if (t >= 20 && t < 24) y += 10; // Q
        else if (t >= 24 && t < 30) y -= 40; // R (peak)
        else if (t >= 30 && t < 34) y += 15; // S
        // T wave (medium bump)
        else if (t > 40 && t < 60) y -= 8 * Math.sin((t - 40) / 20 * Math.PI);


        // Draw segment
        ecgCtx.beginPath();
        ecgCtx.moveTo(x, lastY);
        ecgCtx.lineTo(x + speed, y);
        ecgCtx.stroke();

        lastY = y;
        x += speed;

        // Wrap around
        if (x > width) {
          x = 0;
          ecgCtx.moveTo(0, centerY);
          ecgCtx.fillStyle = '#fff';
          ecgCtx.fillRect(0, 0, width, height);
          ecgCtx.beginPath(); // reset path
        } else {
          // Clear a small bar ahead of the drawing point
          ecgCtx.fillStyle = '#fff';
          ecgCtx.fillRect(x + speed, 0, 10, height);
        }

        ecgFrame = requestAnimationFrame(loop);
      }

      loop();
    }

    function stopECGAnimation() {
      if (ecgFrame) cancelAnimationFrame(ecgFrame);
    }

    // Í≤∞Í≥º ÏÉùÏÑ±
    function generateResult(measuredBpm) {
      console.log("measuredBpm from PPG:", measuredBpm);

      let bpm;
      if (typeof measuredBpm === "number" && measuredBpm > 30) {
        bpm = Math.max(50, Math.min(140, measuredBpm));
      } else {
        // Fallback if measurement failed or is too low
        let base = 70 + Math.floor(Math.random() * 30); // 70-100 range safe
        bpm = Math.max(50, Math.min(120, base));
      }

      lastMeasuredBpm = bpm;

      // Reset Carousel
      showSlide(1);

      // 1. BPM Display (Page 1)
      animateValue(bpmEl, 0, bpm, 1500);

      // Start ECG Animation
      startECGAnimation(bpm);

      // 2. Label & Insight
      let label;
      if (bpm < 60) label = "slow, steady rhythm";
      else if (bpm < 80) label = "calm but reactive rhythm";
      else if (bpm < 95) label = "sensitive, responsive rhythm";
      else label = "intense, over-alert rhythm";
      labelEl.textContent = label;

      // Generate Data if empty
      if (populationData.length === 0) generateFakePopulation();

      // 3. Render Components (Page 4 & 5)
      // We render them immediately, but they will be hidden until slide is shown
      drawClusterMap(bpm);
      updateGauge(bpm);
      updateNeighborhoodStats(bpm);
      drawHistogram(bpm);
      findHeartTwin(bpm);
    }

    // Heart Twin data pool - diverse fake visitors from around the world
    const heartTwinPool = [
      { name: "A Traveler", location: "Tokyo, Japan", country: "üáØüáµ" },
      { name: "A Dreamer", location: "New York, USA", country: "üá∫üá∏" },
      { name: "A Student", location: "Berlin, Germany", country: "üá©üá™" },
      { name: "A Visitor", location: "Paris, France", country: "üá´üá∑" },
      { name: "A Wanderer", location: "Seoul, Korea", country: "üá∞üá∑" },
      { name: "A Thinker", location: "London, UK", country: "üá¨üáß" },
      { name: "A Stranger", location: "Sydney, Australia", country: "üá¶üá∫" },
      { name: "A Soul", location: "S√£o Paulo, Brazil", country: "üáßüá∑" },
      { name: "A Heart", location: "Barcelona, Spain", country: "üá™üá∏" },
      { name: "A Spirit", location: "Amsterdam, Netherlands", country: "üá≥üá±" },
      { name: "A Person", location: "Toronto, Canada", country: "üá®üá¶" },
      { name: "A Mind", location: "Singapore", country: "üá∏üá¨" },
    ];

    let currentHeartTwin = null;

    function findHeartTwin(userBpm) {
      console.log("findHeartTwin called with userBpm:", userBpm);

      // Pick a random twin from the pool
      const randomIndex = Math.floor(Math.random() * heartTwinPool.length);
      const twin = heartTwinPool[randomIndex];

      // Generate a BPM close to the user's (within ¬±3 bpm for "exact match" feel)
      // Ensure userBpm is a valid number, fallback to 75 if not
      const safeBpm = (typeof userBpm === 'number' && !isNaN(userBpm)) ? userBpm : 75;
      const twinBpm = safeBpm + Math.floor(Math.random() * 7) - 3;

      currentHeartTwin = {
        ...twin,
        bpm: twinBpm
      };

      console.log("Heart Twin matched:", twin.name, twin.location, twinBpm, "bpm");

      // Update the profile card elements
      const flagEl = document.getElementById('twin-flag');
      const nameEl = document.getElementById('twin-name');
      const locationEl = document.getElementById('twin-location');
      const bpmEl = document.getElementById('twin-bpm');

      if (flagEl) flagEl.textContent = twin.country;
      if (nameEl) nameEl.textContent = twin.name;
      if (locationEl) locationEl.textContent = twin.location;
      if (bpmEl) bpmEl.textContent = twinBpm;
    }

    // Heart Twin Card Reveal
    let twinCardRevealed = false;
    const twinCardContainer = document.getElementById('twin-card-container');
    const twinHint = document.getElementById('twin-hint');

    function resetHeartTwinCard() {
      twinCardRevealed = false;
      if (twinCardContainer) {
        twinCardContainer.classList.remove('revealed');
      }
      if (twinHint) {
        twinHint.textContent = 'Tap the card to reveal ‚Üí';
      }
    }

    function revealHeartTwinCard() {
      if (twinCardRevealed) return;
      twinCardRevealed = true;

      if (twinCardContainer) {
        twinCardContainer.classList.add('revealed');
      }
      if (twinHint) {
        twinHint.textContent = 'Tap to see the message ‚Üí';
      }
    }

    // Add click event for Heart Twin card reveal
    if (twinCardContainer) {
      twinCardContainer.addEventListener('click', (e) => {
        e.stopPropagation();
        if (!twinCardRevealed) {
          revealHeartTwinCard();
        } else {
          // If already revealed, go to next slide
          nextSlide();
        }
      });
    }

    function updateGauge(bpm) {
      let pct;
      let text;

      if (bpm >= 130) {
        // Faster than Average
        pct = 85; // Fixed high position
        text = "Faster than Average";
      } else {
        // Always Average for < 130
        pct = 50; // Center position
        text = "Average Rhythm";
      }

      // Store target for animation
      gaugeFill.dataset.target = `${pct}%`;
      gaugeMarker.dataset.target = `${pct}%`;

      // Reset to 0 initially
      gaugeFill.style.width = '0%';
      gaugeMarker.style.left = '0%';

      // Update text
      gaugeText.textContent = text;
    }

    // Modified Update Functions
    let lastMeasuredBpm = 80; // Store for redraws

    function updateNeighborhoodStats(userBpm) {
      let range2 = populationData.filter(p => Math.abs(p.bpm - userBpm) <= 2).length;
      let range5 = populationData.filter(p => Math.abs(p.bpm - userBpm) <= 5).length;
      let exact = populationData.filter(p => p.bpm === userBpm).length;

      // Force minimum values to ensure "connection" message
      // If data is sparse, we simulate "other visitors"
      if (range2 < 3) range2 = 3 + Math.floor(Math.random() * 8); // Min 3-10
      if (range5 <= range2) range5 = range2 + 5 + Math.floor(Math.random() * 10); // Ensure range5 > range2
      if (exact < 1) exact = 1; // At least "You"

      const el2 = document.getElementById('nb-count-2');
      const el5 = document.getElementById('nb-count-5');
      const elU = document.getElementById('nb-count-unique');

      // Store target and set to 0/--
      el2.dataset.target = range2;
      el2.textContent = "0";

      el5.dataset.target = range5;
      el5.textContent = "0";

      elU.dataset.target = exact;
      elU.textContent = "0";
    }

    function drawHistogram(userBpm) {
      // Skip if histogram element doesn't exist (slide was removed)
      if (!histWrap) return;

      histWrap.innerHTML = "";
      const bins = [50, 60, 70, 80, 90, 100, 110, 120];
      const counts = new Array(bins.length).fill(0);

      populationData.forEach(p => {
        for (let i = 0; i < bins.length; i++) {
          if (p.bpm >= bins[i] && p.bpm < bins[i] + 10) {
            counts[i]++;
            break;
          }
        }
      });

      const maxCount = Math.max(...counts);

      counts.forEach((count, i) => {
        const bar = document.createElement('div');
        bar.className = 'hist-bar';
        const heightPct = (count / maxCount) * 100;

        // Set initial height to 0 and store target
        bar.style.height = '0%';
        bar.dataset.height = `${heightPct}%`;

        bar.setAttribute('data-count', count);

        if (userBpm >= bins[i] && userBpm < bins[i] + 10) {
          bar.classList.add('active');
          histInsight.textContent = `Most hearts today gathered around ${bins[i]}‚Äì${bins[i] + 10} bpm ‚Äî yours is one of them.`;
        }

        histWrap.appendChild(bar);
      });
    }

    function drawClusterMap(userBpm, progress = 1) {
      const w = clusterCanvas.width;
      const h = clusterCanvas.height;
      clusterCtx.clearRect(0, 0, w, h);

      // Draw Population (Global Scatter)
      // Animate: Draw only a subset based on progress OR draw all with opacity

      const countToDraw = Math.floor(populationData.length * progress);

      for (let i = 0; i < countToDraw; i++) {
        const p = populationData[i];
        // We need stable random positions. 
        // Problem: previous code generated random x,y inside the loop. 
        // We need to generate them once and store them.
        // Let's assume populationData has x,y now. 
        // If not, we should add them in generateFakePopulation.

        // Fallback if no x,y (should fix generateFakePopulation too)
        const x = p.x || Math.random() * w;
        const y = p.y || Math.random() * h;

        clusterCtx.beginPath();
        clusterCtx.arc(x, y, 1.5, 0, Math.PI * 2);

        if (p.bpm < 70) clusterCtx.fillStyle = "rgba(16, 185, 129, 0.6)";
        else if (p.bpm < 90) clusterCtx.fillStyle = "rgba(245, 158, 11, 0.6)";
        else clusterCtx.fillStyle = "rgba(239, 68, 68, 0.6)";

        clusterCtx.fill();
      }

      // Draw User (South Korea) - Only if progress is near end
      if (progress > 0.8) {
        const userX = w * 0.82;
        const userY = h * 0.38;

        // Fade in user
        const userOpacity = (progress - 0.8) * 5; // 0 to 1

        // Glow
        const grad = clusterCtx.createRadialGradient(userX, userY, 2, userX, userY, 20);
        grad.addColorStop(0, `rgba(67, 97, 238, ${userOpacity})`);
        grad.addColorStop(0.5, `rgba(67, 97, 238, ${userOpacity * 0.5})`);
        grad.addColorStop(1, "rgba(67, 97, 238, 0)");
        clusterCtx.fillStyle = grad;
        clusterCtx.beginPath();
        clusterCtx.arc(userX, userY, 20, 0, Math.PI * 2);
        clusterCtx.fill();

        // Pulse Animation Ring
        const time = Date.now() / 1000;
        const radius = 10 + Math.sin(time * 3) * 5;
        clusterCtx.beginPath();
        clusterCtx.arc(userX, userY, radius, 0, Math.PI * 2);
        clusterCtx.strokeStyle = `rgba(255, 255, 255, ${userOpacity * 0.8})`;
        clusterCtx.lineWidth = 1;
        clusterCtx.stroke();

        // Dot
        clusterCtx.beginPath();
        clusterCtx.arc(userX, userY, 6, 0, Math.PI * 2);
        clusterCtx.fillStyle = `rgba(255, 255, 255, ${userOpacity})`;
        clusterCtx.fill();
        clusterCtx.strokeStyle = `rgba(67, 97, 238, ${userOpacity})`; // var(--primary)
        clusterCtx.lineWidth = 2;
        clusterCtx.stroke();

        // Label
        clusterCtx.fillStyle = `rgba(255, 255, 255, ${userOpacity})`;
        clusterCtx.font = "bold 12px Montserrat Alternates";
        clusterCtx.textAlign = "center";
        clusterCtx.fillText("You", userX, userY + 25);
      }
    }

    // Update generateFakePopulation to include x,y
    function generateFakePopulation() {
      populationData = [];
      const count = 200;
      const mean = 80;
      const std = 15;
      const w = clusterCanvas.width;
      const h = clusterCanvas.height;

      for (let i = 0; i < count; i++) {
        const u = 1 - Math.random();
        const v = Math.random();
        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        const bpm = Math.round(z * std + mean);
        const variability = Math.random() * 100;
        // Pre-calculate positions
        const x = Math.random() * w;
        const y = Math.random() * h;

        populationData.push({ bpm, variability, id: i + 1, x, y });
      }
    }

    function animateValue(obj, start, end, duration) {
      let startTimestamp = null;
      const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        const current = Math.floor(progress * (end - start) + start);
        obj.textContent = `${current} bpm`;
        if (progress < 1) {
          window.requestAnimationFrame(step);
        }
      };
      window.requestAnimationFrame(step);
    }

    // --- ENDING PAGE ANIMATION ---
    let endingAnimId;
    class EndingParticle {
      constructor(canvasWidth, canvasHeight) {
        this.cw = canvasWidth;
        this.ch = canvasHeight;
        this.x = Math.random() * this.cw;
        this.y = Math.random() * this.ch;
        this.size = Math.random() * 2 + 1;
        // Brand Blue: #4361EE -> 67, 97, 238
        this.color = `rgba(67, 97, 238, ${Math.random() * 0.6 + 0.4})`;

        // Phase 1: Random float (Faster)
        this.vx = (Math.random() - 0.5) * 1.5;
        this.vy = (Math.random() - 0.5) * 1.5;

        // Target for Phase 2 (Center)
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100; // Cluster radius
        this.tx = this.cw / 2 + Math.cos(angle) * radius;
        this.ty = this.ch / 2 + Math.sin(angle) * radius;
      }

      update(phase, time) {
        if (phase === 'float') {
          this.x += this.vx;
          this.y += this.vy;
          if (this.x < 0 || this.x > this.cw) this.vx *= -1;
          if (this.y < 0 || this.y > this.ch) this.vy *= -1;
        } else if (phase === 'gather') {
          // Move towards target (Faster)
          this.x += (this.tx - this.x) * 0.08;
          this.y += (this.ty - this.y) * 0.08;
        } else if (phase === 'pulse') {
          // Pulse effect
          const pulse = Math.sin(time * 0.008) * 15; // Faster pulse
          this.x += (this.tx - this.x) * 0.1 + (Math.random() - 0.5);
          this.y += (this.ty - this.y) * 0.1 + (Math.random() - 0.5);
        } else if (phase === 'disperse') {
          // Float upward (Faster)
          this.y -= Math.random() * 3 + 2;
          this.x += (Math.random() - 0.5) * 2;
          this.color = `rgba(67, 97, 238, ${Math.random() * 0.5})`; // Fade out blue
        }
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }

    function animateEnding() {
      // Get all text lines for the cinematic ending
      const lines = document.querySelectorAll('.ending-line-cinematic');

      // Reset all lines first
      lines.forEach(line => {
        line.classList.remove('visible');
        line.classList.remove('fade-out');
      });

      // PHASE 1: Show first 4 sentences sequentially
      const phase1Timings = [
        800,    // "Different opinions."
        2000,   // "Different fears."
        3200,   // "Different sides."
        4800,   // "Yet every heart..." 
      ];

      // Show first 4 lines
      phase1Timings.forEach((timing, index) => {
        setTimeout(() => {
          if (lines[index]) {
            lines[index].classList.add('visible');
          }
        }, timing);
      });

      // PHASE 2: Fade out first 4 sentences after they've all appeared
      const fadeOutTime = 7000; // When to start fading out
      setTimeout(() => {
        // Fade out first 4 lines
        for (let i = 0; i < 4; i++) {
          if (lines[i]) {
            lines[i].classList.remove('visible');
            lines[i].classList.add('fade-out');
          }
        }
      }, fadeOutTime);

      // PHASE 3: Show final statement after fade out complete
      const finalStatementTime = 8500; // After fade out transition
      setTimeout(() => {
        if (lines[4]) {
          lines[4].classList.add('visible'); // "Different is not wrong."
        }
      }, finalStatementTime);

      // PHASE 4: Show Try Again button
      const buttonTime = 10500;
      setTimeout(() => {
        if (lines[5]) {
          lines[5].classList.add('visible'); // Try Again button
        }
      }, buttonTime);
    }
    function resetApp() {
      // 1. Reset Variables
      answers = {};
      ppgSignal = [];
      timestamps = [];
      userBpm = 0;
      currentSlide = 1;

      // 2. Reset UI Screens
      show(intro);
      rScreen.style.display = 'none';
      document.getElementById('screen-measure').style.display = 'none';
      document.getElementById('screen-pre-measure').style.display = 'none';

      // Hide all questions
      document.querySelectorAll('.card').forEach(el => {
        if (el.id !== 'screen-intro') el.style.display = 'none';
      });

      // 3. Reset Visuals
      // Clear Graphs
      const gCtx = graphCanvas.getContext('2d');
      gCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

      // Reset Progress Bars
      document.querySelectorAll('.fill').forEach(el => el.style.width = '0%');

      // Reset Result Slides
      for (let i = 1; i <= totalSlides; i++) {
        const slide = document.getElementById(`slide-${i}`);
        slide.classList.remove('active');
        if (i === 1) slide.classList.add('active');
      }

      // Reset Animations
      cancelAnimationFrame(endingAnimId);
      const endingCanvas = document.getElementById('ending-canvas');
      if (endingCanvas) {
        const ctx = endingCanvas.getContext('2d');
        ctx.clearRect(0, 0, endingCanvas.width, endingCanvas.height);
      }

      // Reset Text Opacity in Ending
      document.querySelectorAll('.ending-line').forEach(l => l.style.opacity = 0);
    }

    // Initialize
    show(intro);
    // generateResult(75); // Force result screen
    // show(rScreen);
  </script>
</body>

</html>