<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Different is not wrong – Stress Rhythm Check</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Montserrat+Alternates:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">

</head>

<body>
  <div class="shell">

    <!-- INTRO -->
    <div class="card" id="screen-intro">
      <div class="tagline">Different is not wrong</div>
      <h1 class="intro_h1">Take care of<br>your mental health</h1>
      <p>
        Check your stress levels quickly and easily, and restore your mental wellbeing.
      </p>
      <div class="btn-row">
        <button class="primary" id="btn-start">Start Stress Check</button>
      </div>
    </div>

    <!-- Q1 -->
    <div class="card" id="q1" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q1">← Back</button>
        <div class="progress-bar">
          <div class="fill" style="width:25%;"></div>
        </div>
      </div>
      <div class="step-label">Question 1 of 5</div>
      <h2>What is your <span class="orange_txt">age group?</span></h2>
      <p>Please answer honestly, just as you normally think.</p>
      <div class="options-block">
        <div class="opt" data-key="identity">10s</div>
        <div class="opt" data-key="identity">20s</div>
        <div class="opt" data-key="identity">30s</div>
        <div class="opt" data-key="identity">40s</div>
        <div class="opt" data-key="identity">50s</div>
        <div class="opt" data-key="identity">over 60s</div>
      </div>
    </div>


    <!-- Q2 -->
    <div class="card" id="q2" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q2">← Back</button>
        <div class="progress-bar">
          <div class="fill" style="width:50%;"></div>
        </div>
      </div>
      <div class="step-label">Question 2 of 5</div>
      <h2>Should a government be allowed to <span class="orange_txt">restrict civil liberties</span> during a national
        emergency?</h2>
      <img src="q2.jpg" alt="Question 2 Image" class="q-image">
      <p>Please answer honestly, just as you normally think.</p>
      <div class="options-block">
        <div class="opt" data-key="politics">Yes</div>
        <div class="opt" data-key="politics">Sometimes</div>
        <div class="opt" data-key="politics">Rarely</div>
        <div class="opt" data-key="politics">Never</div>
      </div>
    </div>


    <!-- Q3 -->
    <div class="card" id="q3" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q3">← Back</button>
        <div class="progress-bar">
          <div class="fill" style="width:75%;"></div>
        </div>
      </div>
      <div class="step-label">Question 3 of 5</div>
      <h2>Do you support European bans on <span class="orange_txt">full-face religious coverings</span> <span
          class="small_txt">(burqa/niqab)</span> in
        public spaces?</h2>
      <img src="q3.jpg" alt="Question 3 Image" class="q-image">
      <p>Please answer honestly, just as you normally think.</p>
      <div class="options-block">
        <div class="opt" data-key="gender">Support</div>
        <div class="opt" data-key="gender">Oppose</div>
        <div class="opt" data-key="gender">Depends</div>
        <div class="opt" data-key="gender">Not sure</div>
      </div>
    </div>

    <!-- Q4 -->
    <div class="card" id="q4" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q4">← Back</button>
        <div class="progress-bar">
          <div class="fill" style="width:80%;"></div>
        </div>
      </div>
      <div class="step-label">Question 4 of 5</div>
      <h2>How do you view Spain’s <span class="orange_txt">‘Okupa’</span> movement ?</h2>
      <p>Okupa :People, illegally occupying empty homes.</p>
      <img src="q4_rr.png" alt="Question 4 Image" class="q-image">
      <p>Please answer honestly, just as you normally think.</p>
      <div class="options-block">
        <div class="opt" data-key="identity">Justified</div>
        <div class="opt" data-key="identity">Unjustified</div>
        <div class="opt" data-key="identity">Context matters</div>
        <div class="opt" data-key="identity">Not sure</div>
      </div>
    </div>

    <!-- Q5 -->
    <div class="card" id="q5" style="display:none;">
      <div class="top-nav">
        <button class="back-btn" id="back-q5">← Back</button>
        <div class="progress-bar">
          <div class="fill" style="width: 100%;"></div>
        </div>
      </div>
      <div class="step-label">Question 5 of 5</div>
      <h2>How do you view the <span class="orange_txt">rising age-based hostility</span> toward older adults in Korea’s
        pension debates?</h2>
      <img src="q5.jpg" alt="Question 5 Image" class="q-image">
      <p>There is no right or wrong answer.</p>
      <div class="options-block">
        <div class="opt" data-key="stress">Support</div>
        <div class="opt" data-key="stress">Oppose</div>
        <div class="opt" data-key="stress">Depends</div>
        <div class="opt" data-key="stress">Not sure</div>
      </div>
    </div>



    <!-- PRE-MEASURE INSTRUCTION -->
    <div class="card" id="screen-pre-measure" style="display:none;">

      <!-- Top Interaction pointing to camera -->
      <!-- Top Interaction pointing to camera (Moved to global) -->

      <div class="step-label">Preparation</div>
      <h2 class="center" style="margin-bottom: 10px;">Ready to measure?</h2>
      <p class="center">For an accurate stress index, we will measure your heart rate.</p>

      <!-- Line Illustration -->
      <div class="illustration-wrap">
        <img src="Frame 1.png" alt="iPad Camera Instruction" class="instruction-img">
      </div>

      <p class="center" style="margin-top:20px;">
        Please cover the <strong>front camera</strong> completely with your fingertip.
      </p>

      <div class="btn-row">
        <button class="primary" id="btn-start-measure">Start Measurement</button>
      </div>
    </div>

    <!-- STEP 2: MEASURE -->
    <div class="card" id="screen-measure" style="display:none;">
      <div class="step-label">Step 2 · Heart rhythm capture</div>
      <div class="center">
        <h2>Please cover the camera<br> with your fingertip.</h2>
        <p>Breathe in and out comfortably.</p>

        <div class="camera-wrap" id="camera-wrap">
          <video id="cam" autoplay playsinline></video>

        </div>

        <p class="tiny">Gently cover the camera with your fingertip and stay still for a moment.</p>


        <div class="loader"></div>
        <div class="scan-percent" id="scan-percent">Requesting camera permission…</div>

        <!-- 실시간 심박 그래프 -->
        <!-- 실시간 심박 그래프 -->
        <canvas id="graph" width="320" height="80"></canvas>
        <p class="tiny" id="signal-status"></p>
        <p class="tiny">
          This heartbeat is estimated from tiny light changes on your fingertip.
          It is not a medical measurement, but a way to visualize your rhythm.
        </p>
      </div>
    </div>

    <!-- STEP 3: RESULT -->
    <!-- STEP 3: RESULT CAROUSEL -->
    <div id="screen-result" style="display:none;">
      <div class="carousel-container" id="result-carousel">

        <!-- PAGE 1: Visitor’s Heartbeat (Formerly Slide 3) -->
        <div class="result-slide active" id="slide-1">
          <div class="slide-content center-text">
            <p class="fade-in-text">Here is the rhythm your heart made.</p>

            <!-- Heart Rate Graphic -->
            <div class="ecg-wrap fade-in-text delay-1">
              <canvas id="result-ecg-canvas" width="300" height="100"></canvas>
            </div>

            <div class="result-bpm fade-in-text delay-1" id="result-bpm">– bpm</div>
            <div class="result-label fade-in-text delay-2" id="result-label">unique rhythm pattern</div>
          </div>
          <div class="tap-hint">Tap to turn the page →</div>
        </div>

        <!-- PAGE 2: The World View (Formerly Slide 1) -->
        <div class="result-slide" id="slide-2">
          <div class="slide-content center-text">
            <h2 class="fade-in-text">There are more than<br><span class="bold">8.2 billion people</span><br>living
              completely different lives.
            </h2>
            <img src="world_map.jpg" class="fade-in-image delay-2" alt="World Map">
            <p class="fade-in-text delay-1">Some start before sunrise.<br>Some move slowly.<br>Some feel safe.<br>Some
              feel watched.</p>
          </div>
          <div class="tap-hint">Tap to turn the page →</div>
        </div>

        <!-- PAGE 3: Zoom Into the Visitor (Formerly Slide 2) -->
        <div class="result-slide" id="slide-3">
          <div class="slide-content center-text">
            <h2 class="fade-in-text">Different is Not Wrong.</h2>
            <p>Just as everyone lives<br>in different environments<br>and rhythms,</p>

            <div class="cluster-map-wrap" style="margin-top: 24px;">
              <img src="world_map.jpg" class="map-bg" alt="World Map">
              <canvas id="cluster-canvas" width="300" height="200"></canvas>
            </div>
            <div class="distribution-desc">
              Each dot is one visitor’s rhythm today.<br>One glowing point is yours.
            </div>
          </div>
          <div class="tap-hint">Tap to turn the page →</div>
        </div>

        <!-- PAGE 4: Position Among Others (Gauge) -->
        <div class="result-slide" id="slide-4">
          <div class="slide-content">
            <h2 class="slide-title fade-in-text">This is where your rhythm sits among the others who stood here today.
            </h2>

            <div class="gauge-card fade-in-text delay-1">
              <div class="gauge-wrap">
                <div class="gauge-bar">
                  <div class="gauge-fill" id="gauge-fill"></div>
                  <div class="gauge-marker" id="gauge-marker"></div>
                </div>
                <div class="gauge-labels">
                  <span>Slower</span>
                  <span id="gauge-text">Average</span>
                  <span>Faster</span>
                </div>
              </div>
              <div class="distribution-insight" id="gauge-insight">
                Your heart rhythm is being compared to the crowd.
              </div>
            </div>

          </div>
          <div class="tap-hint">Tap to turn the page →</div>
        </div>

        <!-- PAGE 5: Crowd Visualization -->
        <!-- PAGE 5: Chunk A (Neighborhood) -->
        <div class="result-slide" id="slide-5">
          <div class="slide-content center-text">
            <div class="distribution-card" style="margin-top: 0;">
              <div class="distribution-title">People who moved like you today</div>
              <div class="neighborhood-wrap">
                <div class="nb-card">
                  <div class="nb-count" id="nb-count-2">--</div>
                  <div class="nb-label">Almost the same beat</div>
                </div>
                <div class="nb-card">
                  <div class="nb-count" id="nb-count-5">--</div>
                  <div class="nb-label">Similar rhythm</div>
                </div>
                <div class="nb-card">
                  <div class="nb-count" id="nb-count-unique">--</div>
                  <div class="nb-label">Exactly your beat</div>
                </div>
              </div>
              <div class="distribution-desc">
                Quite a few hearts today moved almost like yours.
              </div>
            </div>
          </div>
          <div class="tap-hint">Tap to turn the page →</div>
        </div>

        <!-- PAGE 6: Chunk B (Histogram) -->
        <div class="result-slide" id="slide-6">
          <div class="slide-content center-text">
            <div class="distribution-card">
              <div class="distribution-title">Where today’s visitors gathered</div>
              <div class="histogram-wrap" id="histogram-wrap">
                <!-- Bars injected by JS -->
              </div>
              <div class="distribution-insight" id="hist-insight">
                Most hearts today gathered around 70–90 bpm — yours is one of them.
              </div>
            </div>
          </div>
          <div class="tap-hint">Tap to turn the page →</div>
        </div>

        <!-- PAGE 7: Chunk D (Heart Twin) -->
        <div class="result-slide" id="slide-7">
          <div class="slide-content center-text">
            <div class="heart-twin-card">
              <div class="distribution-title">Your Heart Twin</div>
              <div class="twin-icon">❤️</div>
              <div class="distribution-desc" id="twin-desc">
                Finding match...
              </div>
              <div class="distribution-desc" style="margin-top: 16px;">
                Somewhere in this crowd,<br>someone’s heart beats just like yours.
              </div>
            </div>
          </div>
          <div class="tap-hint">Tap to see the message →</div>
        </div>

        <!-- PAGE 8: Ending -->
        <div class="result-slide" id="slide-8">
          <div class="slide-content center-text">
            <div class="ending-message">
              <p>Different opinions.<br>Different fears.<br>Different sides.</p>
              <p style="margin-top: 24px;">Yet every heart here moved inside the same human range.</p>
              <h2 style="margin-top: 40px; font-size: 28px; color: var(--primary);">Different is not wrong.</h2>
            </div>

            <button class="btn-primary" onclick="location.reload()" style="margin-top: 40px;">
              Try Again
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- PPG 분석용 숨은 캔버스 -->
    <canvas id="ppg-canvas" width="64" height="48" style="display:none;"></canvas>

  </div>

  <!-- Global Instruction Graphic (Fixed to Top) -->
  <div class="instruction-graphic" id="instruction-graphic" style="display:none;">
    <div class="finger-cue"></div>
    <div class="arrow-cue">↑</div>
  </div>

  <script>
    // 화면 요소들
    const intro = document.getElementById('screen-intro');
    const q1 = document.getElementById('q1');
    const q2 = document.getElementById('q2');
    const q3 = document.getElementById('q3');
    const q4 = document.getElementById('q4');
    const q5 = document.getElementById('q5');
    const pmScreen = document.getElementById('screen-pre-measure');
    const mScreen = document.getElementById('screen-measure');
    const rScreen = document.getElementById('screen-result');
    const instructionGraphic = document.getElementById('instruction-graphic');

    const btnStart = document.getElementById('btn-start');
    const btnStartMeasure = document.getElementById('btn-start-measure');
    const btnRestart = document.getElementById('btn-restart');

    const backQ1 = document.getElementById('back-q1');
    const backQ2 = document.getElementById('back-q2');
    const backQ3 = document.getElementById('back-q3');
    const backQ4 = document.getElementById('back-q4');
    const backQ5 = document.getElementById('back-q5');

    const bpmEl = document.getElementById('result-bpm');
    const labelEl = document.getElementById('result-label');

    const nrMarkerLine = document.getElementById("nr-marker-line");
    const nrMarkerDot = document.getElementById("nr-marker-dot");
    const nrMarkerLabel = document.getElementById("nr-marker-label");
    const nrBpmInline = document.getElementById("nr-bpm-inline");


    const scanPercentEl = document.getElementById('scan-percent');
    const signalStatusEl = document.getElementById('signal-status');
    const camWrap = document.getElementById('camera-wrap');
    const video = document.getElementById('cam');

    const ppgCanvas = document.getElementById('ppg-canvas');
    const ppgCtx = ppgCanvas.getContext('2d');

    const graphCanvas = document.getElementById('graph');
    const graphCtx = graphCanvas.getContext('2d');



    function updateNormalMarker(bpm) {
      const normalMin = 50;
      const normalMax = 120;
      const range = normalMax - normalMin;

      const clamped = Math.max(normalMin, Math.min(normalMax, bpm));
      const t = (clamped - normalMin) / range; // 0~1

      // boundary: 10% ~ 90%
      const x = 10 + t * 80;

      nrMarkerLine.setAttribute("x1", x);
      nrMarkerLine.setAttribute("x2", x);
      nrMarkerDot.setAttribute("cx", x);
      nrMarkerLabel.setAttribute("x", x);

      nrBpmInline.textContent = `${bpm} bpm`;
    }

    let camStream = null;
    let scanAnimFrame = null;

    // PPG 수집용
    let ppgData = [];     // {t, v}
    let ppgFrameHandle = null;
    let ppgStartTime = 0;

    let graphData = [];
    const QUALITY_WIN = 40;
    let qualityWindow = [];
    let signalOk = false;
    let ppgMode = false;

    let scanProgress = 0;

    let answers = {
      politics: null,
      gender: null,
      identity: null,
      stress: null,
    };

    function show(screen) {
      // Hide all screens
      [intro, q1, q2, q3, q4, q5, pmScreen, mScreen, rScreen].forEach(s => s.style.display = 'none');
      // Show target
      screen.style.display = 'block';

      // Toggle global instruction graphic
      if (screen === pmScreen) {
        instructionGraphic.style.display = 'block';
      } else {
        instructionGraphic.style.display = 'none';
      }

      // Scroll to top
      window.scrollTo(0, 0);
    }

    btnStart.onclick = () => show(q1);

    // 측정 시작 버튼
    btnStartMeasure.onclick = () => {
      show(mScreen);
      startCamera();
    };

    // 뒤로가기
    backQ1.onclick = () => show(intro);
    backQ2.onclick = () => show(q1);
    backQ3.onclick = () => show(q2);
    backQ4.onclick = () => show(q3);
    backQ5.onclick = () => show(q4);

    // 질문 선택
    q1.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.politics = opt.textContent.trim();
        q1.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(q2);
      });
    });

    q2.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.gender = opt.textContent.trim();
        q2.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(q3);
      });
    });

    q3.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.gender = opt.textContent.trim();
        q3.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(q4);
      });
    });

    q4.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.identity = opt.textContent.trim();
        q4.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(q5);
      });
    });

    q5.querySelectorAll('.opt').forEach(opt => {
      opt.addEventListener('click', () => {
        answers.stress = opt.textContent.trim();
        q5.querySelectorAll('.opt').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        show(pmScreen);
      });
    });

    // 카메라 + PPG
    async function startCamera() {
      scanPercentEl.textContent = "Requesting camera permission…";
      signalStatusEl.textContent = "";
      scanProgress = 0;
      try {
        camStream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = camStream;
        ppgMode = true;
        startPPG();
        startScanAnimation();
      } catch (e) {
        console.warn("Camera error:", e);
        ppgMode = false;
        signalStatusEl.textContent = "Camera unavailable. We will simulate your rhythm.";
        startScanAnimation();
      }
    }

    function stopCamera() {
      if (!camStream) return;
      camStream.getTracks().forEach(t => t.stop());
      camStream = null;
      video.srcObject = null;
    }

    // PPG 수집 시작
    function startPPG() {
      ppgData = [];
      graphData = [];
      qualityWindow = [];
      signalOk = false;
      ppgStartTime = performance.now();

      function capture(now) {
        if (!video.videoWidth || !video.videoHeight) {
          ppgFrameHandle = requestAnimationFrame(capture);
          return;
        }
        const w = ppgCanvas.width;
        const h = ppgCanvas.height;
        ppgCtx.drawImage(video, 0, 0, w, h);
        const frame = ppgCtx.getImageData(0, 0, w, h).data;
        let sum = 0;
        let count = 0;
        const startX = Math.floor(w * 0.25);
        const endX = Math.floor(w * 0.75);
        const startY = Math.floor(h * 0.25);
        const endY = Math.floor(h * 0.75);

        for (let y = startY; y < endY; y++) {
          for (let x = startX; x < endX; x++) {
            const idx = (y * w + x) * 4;
            const r = frame[idx]; // R 채널
            sum += r;
            count++;
          }
        }
        const avg = sum / count;
        const t = (now - ppgStartTime) / 1000;
        ppgData.push({ t, v: avg });

        // 품질 평가용 윈도우
        qualityWindow.push(avg);
        if (qualityWindow.length > QUALITY_WIN) qualityWindow.shift();
        if (qualityWindow.length >= QUALITY_WIN) {
          let qMin = Infinity, qMax = -Infinity;
          for (const v of qualityWindow) {
            if (v < qMin) qMin = v;
            if (v > qMax) qMax = v;
          }
          const amp = qMax - qMin; // 변화폭
          if (amp < 2) {
            // 거의 변동 없음 → 손가락 안 가려짐/너무 어두움
            signalOk = false;
            signalStatusEl.textContent = "We can’t clearly see your fingertip. Please fully cover the camera and stay still.";
          } else {
            signalOk = true;
            signalStatusEl.textContent = "We are detecting subtle changes in your blood flow. Keep still…";
          }
        } else {
          signalStatusEl.textContent = "Trying to lock onto your rhythm…";
        }

        // 그래프용 데이터
        graphData.push(avg);
        if (graphData.length > 400) graphData.shift();
        drawGraph();

        ppgFrameHandle = requestAnimationFrame(capture);
      }

      if (ppgFrameHandle) cancelAnimationFrame(ppgFrameHandle);
      ppgFrameHandle = requestAnimationFrame(capture);
    }

    function stopPPG() {
      if (ppgFrameHandle) cancelAnimationFrame(ppgFrameHandle);
      ppgFrameHandle = null;
    }

    // 실시간 파형 그래프
    function drawGraph() {
      const w = graphCanvas.width;
      const h = graphCanvas.height;
      graphCtx.clearRect(0, 0, w, h);
      if (graphData.length < 2) return;

      let gMin = Infinity, gMax = -Infinity;
      for (const v of graphData) {
        if (v < gMin) gMin = v;
        if (v > gMax) gMax = v;
      }
      const amp = gMax - gMin || 1;

      graphCtx.beginPath();
      for (let i = 0; i < graphData.length; i++) {
        const norm = (graphData[i] - gMin) / amp; // 0~1
        const x = (i / (graphData.length - 1)) * w;
        const y = h - (0.2 + norm * 0.6) * h;     // 가운데 띠에 그리기
        if (i === 0) graphCtx.moveTo(x, y);
        else graphCtx.lineTo(x, y);
      }
      graphCtx.strokeStyle = 'rgba(186,214,235,0.9)';
      graphCtx.lineWidth = 2;
      graphCtx.stroke();
    }

    // 스캔 진행 (시간 + 신호품질 기반)
    function startScanAnimation() {
      if (scanAnimFrame) cancelAnimationFrame(scanAnimFrame);
      const start = performance.now();
      let last = start;
      scanProgress = 0;

      const TARGET = 12000; // 12초 정도 목표
      const MAX = 18000;    // 최장 18초

      function tick(now) {
        const elapsed = now - start;
        const dt = now - last;
        last = now;

        if (!ppgMode) {
          // 카메라 없는 경우: 그냥 시간 기반
          scanProgress = Math.min(100, (elapsed / TARGET) * 100);
        } else {
          const baseSpeed = (dt / TARGET) * 100;
          const qualityFactor = signalOk ? 1.2 : 0.3; // 품질 나쁘면 느리게
          scanProgress = Math.min(100, scanProgress + baseSpeed * qualityFactor);

          // 너무 오래 걸리면 강제로 마무리
          if (elapsed > MAX && scanProgress < 100) {
            scanProgress = Math.min(100, scanProgress + baseSpeed * 2);
          }
        }

        const pct = Math.round(Math.min(100, scanProgress));
        scanPercentEl.textContent = `Scanning your heart rhythm… ${pct}%`;

        // 카메라 링 속도도 점점 빨라지게
        const progress = pct / 100;
        const duration = 1.6 - progress * 0.6; // 1.6s → 1.0s
        camWrap.style.animationDuration = duration + "s";

        if (pct < 100) {
          scanAnimFrame = requestAnimationFrame(tick);
        } else {
          stopPPG();
          stopCamera();
          const measured = ppgMode ? computeBPMFromPPG(ppgData) : null;
          show(rScreen);
          // Small delay to ensure layout is done
          setTimeout(() => generateResult(measured), 50);
        }
      }
      scanAnimFrame = requestAnimationFrame(tick);
    }

    // PPG → BPM
    function computeBPMFromPPG(data) {
      if (!data || data.length < 30) return null;

      const times = data.map(d => d.t);
      const values = data.map(d => d.v);

      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const centered = values.map(v => v - mean);
      const sq = centered.map(v => v * v);
      const std = Math.sqrt(sq.reduce((a, b) => a + b, 0) / centered.length) || 1;
      const norm = centered.map(v => v / std);

      const win = 5;
      const smooth = norm.map((v, i) => {
        let s = 0, c = 0;
        for (let k = -win; k <= win; k++) {
          const idx = i + k;
          if (idx >= 0 && idx < norm.length) { s += norm[idx]; c++; }
        }
        return s / c;
      });

      const peaks = [];
      const threshold = 0.25;
      for (let i = 1; i < smooth.length - 1; i++) {
        if (smooth[i] > smooth[i - 1] && smooth[i] > smooth[i + 1] && smooth[i] > threshold) {
          peaks.push(i);
        }
      }
      if (peaks.length < 2) return null;

      const intervals = [];
      for (let i = 1; i < peaks.length; i++) {
        const t1 = times[peaks[i - 1]];
        const t2 = times[peaks[i]];
        intervals.push(t2 - t1);
      }
      const avgInt = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      if (!avgInt || avgInt <= 0) return null;

      const bpm = 60 / avgInt;
      if (bpm < 40 || bpm > 180) return null;
      return Math.round(bpm);
    }

    const clusterCanvas = document.getElementById('cluster-canvas');
    const clusterCtx = clusterCanvas.getContext('2d');
    const gaugeFill = document.getElementById('gauge-fill');
    const gaugeMarker = document.getElementById('gauge-marker');
    const gaugeText = document.getElementById('gauge-text');
    const gaugeInsight = document.getElementById('gauge-insight');
    const histWrap = document.getElementById('histogram-wrap');
    const histInsight = document.getElementById('hist-insight');
    const nbCount2 = document.getElementById('nb-count-2');
    const nbCount5 = document.getElementById('nb-count-5');
    const nbCountUnique = document.getElementById('nb-count-unique');
    const twinDesc = document.getElementById('twin-desc');

    // Fake Population Data
    let populationData = [];

    function generateFakePopulation() {
      populationData = [];
      const count = 200;
      const mean = 80;
      const std = 15;

      for (let i = 0; i < count; i++) {
        // Box-Muller transform for normal distribution
        const u = 1 - Math.random();
        const v = Math.random();
        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        const bpm = Math.round(z * std + mean);
        // Variability (fake metric for Y-axis)
        const variability = Math.random() * 100;
        populationData.push({ bpm, variability, id: i + 1 });
      }
    }

    // Carousel Logic
    let currentSlide = 1;
    const totalSlides = 8;

    function showSlide(index) {
      for (let i = 1; i <= totalSlides; i++) {
        const slide = document.getElementById(`slide-${i}`);
        if (i === index) {
          slide.classList.add('active');

          // Trigger Animations based on Slide
          if (index === 3) { // Cluster Map (Moved to Slide 3)
            animateClusterMap();
          } else if (index === 4) { // Gauge
            animateGauge();
          } else if (index === 5) { // Neighborhood
            animateNeighborhood();
          } else if (index === 6) { // Histogram
            animateHistogram();
          }

        } else {
          slide.classList.remove('active');

          // Reset animations if needed (optional, for replayability)
          if (i === 4) resetGauge();
          if (i === 6) resetHistogram();
        }
      }
      currentSlide = index;
    }

    function nextSlide() {
      if (currentSlide < totalSlides) {
        showSlide(currentSlide + 1);
      }
    }

    // Tap to advance
    document.getElementById('result-carousel').addEventListener('click', (e) => {
      // Don't advance if clicking a button
      if (e.target.tagName === 'BUTTON') return;
      nextSlide();
    });

    // Also allow clicking the hint specifically
    document.querySelectorAll('.tap-hint').forEach(hint => {
      hint.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent double firing
        nextSlide();
      });
    });

    // Animation Helpers
    function animateCount(obj, end, duration) {
      if (!obj) return;
      let startTimestamp = null;
      const start = 0;
      const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        // Ease out quart
        const ease = 1 - Math.pow(1 - progress, 4);
        const current = Math.floor(ease * (end - start) + start);
        obj.textContent = current;
        if (progress < 1) {
          window.requestAnimationFrame(step);
        } else {
          obj.textContent = end;
        }
      };
      window.requestAnimationFrame(step);
    }

    function animateNeighborhood() {
      // Get values from data attributes or global state? 
      // We can read the target value from the element if we stored it, 
      // or just re-calculate. Since we have `updateNeighborhoodStats` which sets text,
      // let's modify `updateNeighborhoodStats` to store value in dataset and set text to 0 initially.

      const el2 = document.getElementById('nb-count-2');
      const el5 = document.getElementById('nb-count-5');
      const elU = document.getElementById('nb-count-unique');

      if (el2.dataset.target) animateCount(el2, parseInt(el2.dataset.target), 1500);
      if (el5.dataset.target) animateCount(el5, parseInt(el5.dataset.target), 1500);
      if (elU.dataset.target) animateCount(elU, parseInt(elU.dataset.target), 1500);
    }

    function animateHistogram() {
      const bars = document.querySelectorAll('.hist-bar');
      bars.forEach((bar, i) => {
        setTimeout(() => {
          bar.style.height = bar.dataset.height;
        }, i * 100); // Staggered effect
      });
    }

    function animateGauge() {
      // Small delay to ensure transition works after display block
      setTimeout(() => {
        if (gaugeFill.dataset.target) gaugeFill.style.width = gaugeFill.dataset.target;
        if (gaugeMarker.dataset.target) gaugeMarker.style.left = gaugeMarker.dataset.target;
      }, 100);
    }

    function resetGauge() {
      gaugeFill.style.width = '0%';
      gaugeMarker.style.left = '0%';
    }

    function resetHistogram() {
      const bars = document.querySelectorAll('.hist-bar');
      bars.forEach(bar => {
        bar.style.height = '0%';
      });
    }

    let clusterAnimFrame = null;
    function animateClusterMap() {
      if (clusterAnimFrame) cancelAnimationFrame(clusterAnimFrame);
      const w = clusterCanvas.width;
      const h = clusterCanvas.height;
      // We need userBpm to draw the user dot correctly. 
      // It's not easily accessible here unless we store it globally.
      // Let's assume `lastMeasuredBpm` is available or we pass it.
      // For now, let's make `drawClusterMap` handle the static draw and we just overlay animation?
      // Better: Re-run the draw with a progress factor.

      let progress = 0;
      const duration = 2000;
      let start = null;

      function step(timestamp) {
        if (!start) start = timestamp;
        const elapsed = timestamp - start;
        progress = Math.min(elapsed / duration, 1);

        drawClusterMap(lastMeasuredBpm, progress); // Modified draw function

        if (progress < 1) {
          clusterAnimFrame = requestAnimationFrame(step);
        }
      }
      clusterAnimFrame = requestAnimationFrame(step);
    }

    // ECG Animation
    const ecgCanvas = document.getElementById('result-ecg-canvas');
    const ecgCtx = ecgCanvas.getContext('2d');
    let ecgFrame = null;

    function startECGAnimation(bpm) {
      if (ecgFrame) cancelAnimationFrame(ecgFrame);

      const width = ecgCanvas.width;
      const height = ecgCanvas.height;
      const centerY = height / 2;

      let x = 0;
      const speed = 2; // pixels per frame
      const intervalFrames = (60 / bpm) * 60; // approx frames per beat (assuming 60fps)
      let framesSinceBeat = 0;

      // Clear canvas
      ecgCtx.fillStyle = '#fff';
      ecgCtx.fillRect(0, 0, width, height);
      ecgCtx.lineWidth = 2;
      ecgCtx.strokeStyle = '#EF4444'; // Red color
      ecgCtx.lineCap = 'round';
      ecgCtx.lineJoin = 'round';

      ecgCtx.beginPath();
      ecgCtx.moveTo(0, centerY);

      let lastY = centerY;

      function loop() {
        framesSinceBeat++;

        // Calculate Y based on beat timing
        let y = centerY;

        // Trigger beat
        if (framesSinceBeat >= intervalFrames) {
          framesSinceBeat = 0;
        }

        // Draw the complex at the start of the beat
        const t = framesSinceBeat; // frames into the beat

        // P wave (small bump)
        if (t > 5 && t < 15) y -= 5 * Math.sin((t - 5) / 10 * Math.PI);
        // QRS complex (sharp down-up-down)
        else if (t >= 20 && t < 24) y += 10; // Q
        else if (t >= 24 && t < 30) y -= 40; // R (peak)
        else if (t >= 30 && t < 34) y += 15; // S
        // T wave (medium bump)
        else if (t > 40 && t < 60) y -= 8 * Math.sin((t - 40) / 20 * Math.PI);


        // Draw segment
        ecgCtx.beginPath();
        ecgCtx.moveTo(x, lastY);
        ecgCtx.lineTo(x + speed, y);
        ecgCtx.stroke();

        lastY = y;
        x += speed;

        // Wrap around
        if (x > width) {
          x = 0;
          ecgCtx.moveTo(0, centerY);
          ecgCtx.fillStyle = '#fff';
          ecgCtx.fillRect(0, 0, width, height);
          ecgCtx.beginPath(); // reset path
        } else {
          // Clear a small bar ahead of the drawing point
          ecgCtx.fillStyle = '#fff';
          ecgCtx.fillRect(x + speed, 0, 10, height);
        }

        ecgFrame = requestAnimationFrame(loop);
      }

      loop();
    }

    function stopECGAnimation() {
      if (ecgFrame) cancelAnimationFrame(ecgFrame);
    }

    // 결과 생성
    function generateResult(measuredBpm) {
      console.log("measuredBpm from PPG:", measuredBpm);

      let bpm;
      if (typeof measuredBpm === "number" && measuredBpm > 30) {
        bpm = Math.max(50, Math.min(140, measuredBpm));
      } else {
        // Fallback if measurement failed or is too low
        let base = 70 + Math.floor(Math.random() * 30); // 70-100 range safe
        bpm = Math.max(50, Math.min(120, base));
      }

      lastMeasuredBpm = bpm;

      // Reset Carousel
      showSlide(1);

      // 1. BPM Display (Page 1)
      animateValue(bpmEl, 0, bpm, 1500);

      // Start ECG Animation
      startECGAnimation(bpm);

      // 2. Label & Insight
      let label;
      if (bpm < 60) label = "slow, steady rhythm";
      else if (bpm < 80) label = "calm but reactive rhythm";
      else if (bpm < 95) label = "sensitive, responsive rhythm";
      else label = "intense, over-alert rhythm";
      labelEl.textContent = label;

      // Generate Data if empty
      if (populationData.length === 0) generateFakePopulation();

      // 3. Render Components (Page 4 & 5)
      // We render them immediately, but they will be hidden until slide is shown
      drawClusterMap(bpm);
      updateGauge(bpm);
      updateNeighborhoodStats(bpm);
      drawHistogram(bpm);
      findHeartTwin(bpm);
    }

    function findHeartTwin(userBpm) {
      // Find closest match
      let closest = populationData[0];
      let minDiff = Infinity;

      populationData.forEach(p => {
        const diff = Math.abs(p.bpm - userBpm);
        if (diff < minDiff) {
          minDiff = diff;
          closest = p;
        }
      });

      twinDesc.textContent = `Visitor #${closest.id.toString().padStart(3, '0')} (${closest.bpm} bpm)`;
    }

    function updateGauge(bpm) {
      let pct;
      let text;

      if (bpm >= 130) {
        // Faster than Average
        pct = 85; // Fixed high position
        text = "Faster than Average";
      } else {
        // Always Average for < 130
        pct = 50; // Center position
        text = "Average Rhythm";
      }

      // Store target for animation
      gaugeFill.dataset.target = `${pct}%`;
      gaugeMarker.dataset.target = `${pct}%`;

      // Reset to 0 initially
      gaugeFill.style.width = '0%';
      gaugeMarker.style.left = '0%';

      // Update text
      gaugeText.textContent = text;
    }

    // Modified Update Functions
    let lastMeasuredBpm = 80; // Store for redraws

    function updateNeighborhoodStats(userBpm) {
      let range2 = populationData.filter(p => Math.abs(p.bpm - userBpm) <= 2).length;
      let range5 = populationData.filter(p => Math.abs(p.bpm - userBpm) <= 5).length;
      let exact = populationData.filter(p => p.bpm === userBpm).length;

      // Force minimum values to ensure "connection" message
      // If data is sparse, we simulate "other visitors"
      if (range2 < 3) range2 = 3 + Math.floor(Math.random() * 8); // Min 3-10
      if (range5 <= range2) range5 = range2 + 5 + Math.floor(Math.random() * 10); // Ensure range5 > range2
      if (exact < 1) exact = 1; // At least "You"

      const el2 = document.getElementById('nb-count-2');
      const el5 = document.getElementById('nb-count-5');
      const elU = document.getElementById('nb-count-unique');

      // Store target and set to 0/--
      el2.dataset.target = range2;
      el2.textContent = "0";

      el5.dataset.target = range5;
      el5.textContent = "0";

      elU.dataset.target = exact;
      elU.textContent = "0";
    }

    function drawHistogram(userBpm) {
      histWrap.innerHTML = "";
      const bins = [50, 60, 70, 80, 90, 100, 110, 120];
      const counts = new Array(bins.length).fill(0);

      populationData.forEach(p => {
        for (let i = 0; i < bins.length; i++) {
          if (p.bpm >= bins[i] && p.bpm < bins[i] + 10) {
            counts[i]++;
            break;
          }
        }
      });

      const maxCount = Math.max(...counts);

      counts.forEach((count, i) => {
        const bar = document.createElement('div');
        bar.className = 'hist-bar';
        const heightPct = (count / maxCount) * 100;

        // Set initial height to 0 and store target
        bar.style.height = '0%';
        bar.dataset.height = `${heightPct}%`;

        bar.setAttribute('data-count', count);

        if (userBpm >= bins[i] && userBpm < bins[i] + 10) {
          bar.classList.add('active');
          histInsight.textContent = `Most hearts today gathered around ${bins[i]}–${bins[i] + 10} bpm — yours is one of them.`;
        }

        histWrap.appendChild(bar);
      });
    }

    function drawClusterMap(userBpm, progress = 1) {
      const w = clusterCanvas.width;
      const h = clusterCanvas.height;
      clusterCtx.clearRect(0, 0, w, h);

      // Draw Population (Global Scatter)
      // Animate: Draw only a subset based on progress OR draw all with opacity

      const countToDraw = Math.floor(populationData.length * progress);

      for (let i = 0; i < countToDraw; i++) {
        const p = populationData[i];
        // We need stable random positions. 
        // Problem: previous code generated random x,y inside the loop. 
        // We need to generate them once and store them.
        // Let's assume populationData has x,y now. 
        // If not, we should add them in generateFakePopulation.

        // Fallback if no x,y (should fix generateFakePopulation too)
        const x = p.x || Math.random() * w;
        const y = p.y || Math.random() * h;

        clusterCtx.beginPath();
        clusterCtx.arc(x, y, 1.5, 0, Math.PI * 2);

        if (p.bpm < 70) clusterCtx.fillStyle = "rgba(16, 185, 129, 0.6)";
        else if (p.bpm < 90) clusterCtx.fillStyle = "rgba(245, 158, 11, 0.6)";
        else clusterCtx.fillStyle = "rgba(239, 68, 68, 0.6)";

        clusterCtx.fill();
      }

      // Draw User (South Korea) - Only if progress is near end
      if (progress > 0.8) {
        const userX = w * 0.82;
        const userY = h * 0.38;

        // Fade in user
        const userOpacity = (progress - 0.8) * 5; // 0 to 1

        // Glow
        const grad = clusterCtx.createRadialGradient(userX, userY, 2, userX, userY, 20);
        grad.addColorStop(0, `rgba(67, 97, 238, ${userOpacity})`);
        grad.addColorStop(0.5, `rgba(67, 97, 238, ${userOpacity * 0.5})`);
        grad.addColorStop(1, "rgba(67, 97, 238, 0)");
        clusterCtx.fillStyle = grad;
        clusterCtx.beginPath();
        clusterCtx.arc(userX, userY, 20, 0, Math.PI * 2);
        clusterCtx.fill();

        // Pulse Animation Ring
        const time = Date.now() / 1000;
        const radius = 10 + Math.sin(time * 3) * 5;
        clusterCtx.beginPath();
        clusterCtx.arc(userX, userY, radius, 0, Math.PI * 2);
        clusterCtx.strokeStyle = `rgba(255, 255, 255, ${userOpacity * 0.8})`;
        clusterCtx.lineWidth = 1;
        clusterCtx.stroke();

        // Dot
        clusterCtx.beginPath();
        clusterCtx.arc(userX, userY, 6, 0, Math.PI * 2);
        clusterCtx.fillStyle = `rgba(255, 255, 255, ${userOpacity})`;
        clusterCtx.fill();
        clusterCtx.strokeStyle = `rgba(67, 97, 238, ${userOpacity})`; // var(--primary)
        clusterCtx.lineWidth = 2;
        clusterCtx.stroke();

        // Label
        clusterCtx.fillStyle = `rgba(255, 255, 255, ${userOpacity})`;
        clusterCtx.font = "bold 12px Montserrat Alternates";
        clusterCtx.textAlign = "center";
        clusterCtx.fillText("You", userX, userY + 25);
      }
    }

    // Update generateFakePopulation to include x,y
    function generateFakePopulation() {
      populationData = [];
      const count = 200;
      const mean = 80;
      const std = 15;
      const w = clusterCanvas.width;
      const h = clusterCanvas.height;

      for (let i = 0; i < count; i++) {
        const u = 1 - Math.random();
        const v = Math.random();
        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        const bpm = Math.round(z * std + mean);
        const variability = Math.random() * 100;
        // Pre-calculate positions
        const x = Math.random() * w;
        const y = Math.random() * h;

        populationData.push({ bpm, variability, id: i + 1, x, y });
      }
    }

    function animateValue(obj, start, end, duration) {
      let startTimestamp = null;
      const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        const current = Math.floor(progress * (end - start) + start);
        obj.textContent = `${current} bpm`;
        if (progress < 1) {
          window.requestAnimationFrame(step);
        }
      };
      window.requestAnimationFrame(step);
    }
    // Initialize
    show(intro);
    // generateResult(75); // Force result screen
    // show(rScreen);
  </script>
</body>

</html>